# 쒸프트키까안빠쪄요
## Time Limit: 3 seconds, Memory Limit: 1024 MB

Brainf\*\*k은 Urban Müller가 1993년에 개발한 ‘난해한 프로그래밍 언어’이다. 이 언어는 모든 값이 0으로 초기화되어 있는 배열과 그 배열의 첫 번째 주소를 가리키는 포인터, 이들을 조작하는 8개의 명령어로 이루어져 있는데, Brainf\*\*k으로 작성된 프로그램은 각 명령어를 왼쪽에서 오른쪽으로 순서대로 실행하며 동작한다.

이 문제에서는 다음 3개 명령어만을 이용한다.

* ```+``` : 현재 포인터가 가리키고 있는 위치의 값을 1 증가시킨다.
* ```-``` : 현재 포인터가 가리키고 있는 위치의 값을 1 감소시킨다.
* ```>``` : 포인터의 값을 1 증가시킨다. 즉, 포인터는 가리키고 있던 값의 한 칸 오른쪽에 위치한 값을 가리키게 된다.

```+```, ```-```, ```>```로만 이루어져 있는 길이가 $N$인 문자열 $A = A_1, A_2, ..., A_N$ 이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.

* ```1 L R K```: $A$의 부분 문자열 $A_{L, R} = A_L, A_{L+1}, ..., A_{R-1}, A_R$ 에 대해, $A_{L, R}$ 을 오른쪽으로 $K$만큼 시프트한다.

    즉, $0 < K < R-L$일 때 $A$는 다음과 같이 변화한다.

$$ A_1, ..., A_{L-1}, A_{R-K+1}, ..., A_R, A_L, A_{L+1}, ..., A_{R-K}, A_{R+1}, ..., A_N $$

&emsp;&ensp;&nbsp; 만약 $K < 0$이라면, $A_{L, R}$ 을 왼쪽으로 $|K|$만큼 시프트한다.

* ```2 L R```: $A$의 부분 문자열 $A_{L, R} = A_L, A_{L+1}, ..., A_{R-1}, A_R$ 에 대해, $A_{L, R}$ 을 하나의 Brainf\*\*k 프로그램으로 간주하고 실행한다.

    실행 후 Brainf\*\*k 프로그램의 포인터가 가리키고 있는 값의 인덱스를 $X$라 할 때, 프로그램의 배열의 각 주소에 저장된 값으로 새로운 수열 $B = B_1, B_2, ..., B_X$ 를 만든다.
    
    이후 $B$의 각 원소 중 최댓값을 출력한다.

2번 쿼리가 주어질 때마다 $A_{L, R}$ 은 독립적인 환경에서 실행된다. 즉, 각각의 $A_{L, R}$ 은 배열의 모든 값이 0으로 초기화되어 있고, 포인터가 배열의 첫 번째 주소를 가리키고 있는 상황에서 실행된다.

또한, 이 문제에서는 Brainf\*\*k 프로그램의 배열의 길이는 $N$보다 크며, 배열의 각 주소에 절댓값이 $N$보다 큰 값을 저장할 수 있다고 가정한다.

2번 쿼리는 한 번 이상 주어진다.

## 입력
첫째 줄에 $N$이 주어진다. ($2 \leq N \leq 300,000$)

둘째 줄에는 $A$가 주어진다.

셋째 줄에는 쿼리의 개수 $Q$가 주어진다. ($1 \leq Q \leq 100,000$)

넷째 줄부터 $Q$개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.

1번 쿼리의 경우 $1 \leq L < R \leq N$이며, $1 \leq |K| \leq R-L$을 만족한다.

2번 쿼리의 경우 $1 \leq L \leq R \leq N$을 만족한다.

## 출력
2번 쿼리가 주어질 때마다 정답을 한 줄에 하나씩 출력한다.

## 예시 입력
```
20
+>++---->->>++-++--+
8
2 17 18
2 12 19
1 15 19 4
2 1 16
2 16 19
1 4 18 8
1 13 16 1
2 14 17
```

## 예시 출력
```
0
1
4
-2
0
```

## 힌트
예시 입력으로 주어진 쿼리를 해석하면 다음과 같다.

```2 17 18``` : 실행되는 프로그램은 ```+-```이며, $B = [0]$이다. 따라서 쿼리의 정답은 0이다.

```2 12 19``` : 실행되는 프로그램은 ```>++-++--```이며, $B = [0, 1]$이다. 따라서 쿼리의 정답은 1이다.

```1 15 19 4``` : 쿼리가 주어진 이후 $A$는 ```+>++---->->>++++---+```이 된다.

```2 1 16``` : 실행되는 프로그램은 ```+>++---->->>++++```이며, $B = [1, -2, -1, 0, 4]$이다. 따라서 쿼리의 정답은 4이다.

```2 16 19``` : 실행되는 프로그램은 ```+---```이며, $B = [-2]$이다. 따라서 쿼리의 정답은 –2이다.

* 프로그램의 배열의 모든 값은 0으로 초기화되어 있음에도, 포인터가 움직이지 않았으므로 B의 원소는 –2 하나뿐이다. 따라서 쿼리의 정답은 0이 아니라 -2가 되어야 함에 유의하라.

```1 4 18 8``` : 쿼리가 주어진 이후 $A$는 ```+>+>>++++--+---->--+```이 된다.

```1 13 16 1``` : 쿼리가 주어진 이후 $A$는 ```+>+>>++++--+---->--+```이 된다.

* $A_{13, 16}$은 ```----```이므로 시프트 연산을 하더라도 변화는 없다.

```2 14 17``` : 실행되는 프로그램은 ```--->```이며, $B = [-3, 0]$이다. 따라서 쿼리의 정답은 0이다.