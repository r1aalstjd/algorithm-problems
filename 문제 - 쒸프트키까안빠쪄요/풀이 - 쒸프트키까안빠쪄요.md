# 쒸프트키까안빠쪄요 - Solution
$\definecolor{diamond}{rgb}{0,0.7059,0.9882}$ $\definecolor{ruby}{rgb}{1.0,0,0.3843}$
## 문제 분석
* ⚠️ 이 문제의 난이도는 Solved.ac 기준 $\color{diamond}\texttt{Diamond II}$ ~ $\color{ruby}\texttt{Ruby V}$ 로, 풀이에 Splay Tree 등 고난도 자료구조가 사용됩니다.

1. 문제의 시간 제한과 메모리 제한, 입력 제한을 확인하자.

    N $\leq$ 300,000과 Q $\leq$ 100,000을 만족하고, 시간 제한이 3초이므로 문제에서 요구하는 시간 복잡도는 $O(QN)$ 보다 작다는 사실을 확인할 수 있다.

2. 입력으로 주어지는 쿼리를 확인하자.

    > * ```1 L R K```: A의 부분 문자열 $A_{L, R} = A_L, A_{L+1}, ..., A_{R-1}, A_R$ 에 대해, $A_{L, R}$ 을 오른쪽으로 K만큼 시프트한다.
    > 
    > 즉, 0 < K < R-L일 때 A는 다음과 같이 변화한다.
    > 
    > $A_1, ..., A_{L-1}, A_{R-K+1}, ..., A_R, A_L, A_{L+1}, ..., A_{R-K}, A_{R+1}, ..., A_N$
    > 
    > 만약 K < 0이라면, A_{L, R}을 왼쪽으로 |K|만큼 시프트한다.

    > * ```2 L R```: A의 부분 문자열 $A_{L, R} = A_L, A_{L+1}, ..., A_{R-1}, A_R$ 에 대해, $A_{L, R}$ 을 하나의 Brainf\*\*k 프로그램으로 간주하고 실행한다.
    >
    > 실행 후 Brainf\*\*k 프로그램의 포인터가 가리키고 있는 값의 인덱스를 X라 할 때, 프로그램의 배열의 각 주소에 저장된 값으로 새로운 수열 $B = B_1, B_2, ..., B_X$ 를 만든다.
    > 
    > 이후 B의 각 원소 중 최댓값을 출력한다.

    1번 쿼리는 문자열을 업데이트하고, 2번 쿼리는 문자열로 특정 연산을 시행해서 출력하는 쿼리이다.

    이때, 1번 쿼리가 요구하는 업데이트가 부분 문자열에 대한 시프트 연산이므로, 구간에 대한 뒤집기 쿼리를 쉽게 수행할 수 있는 자료구조가 필요함을 알 수 있다.

    또한, 2번 쿼리를 Naive하게 실행하면 $O(N)$ 의 시간 복잡도가 요구되므로, 적절한 자료구조를 사용해 2번 쿼리의 시간복잡도를 줄이는 것이 핵심이다.

따라서, 이 풀이에서는 구간에 대한 뒤집기 쿼리를 쉽게 수행할 수 있는 자료구조인 Splay Tree를 사용해 2번 쿼리를 효과적으로 처리하는 방법을 이용한다.

## 접근 - 2번 쿼리
2번 쿼리의 내용을 자세히 읽어 보면 다음과 같다.
1. A의 부분 문자열 $A_{L, R}$ 을 Brainf**k 프로그램으로 간주하고, 실행한다.
2. 프로그램이 실행된 후 프로그램의 포인터가 가리키는 인덱스를 X로 둔다.
3. 프로그램의 메모리에 저장된 값으로 수열 B를 만든다.
4. $\textrm{max}_{i=1}^{X}$ $B_{i}$ 을 출력한다.

우선 문제에서 포인터의 값을 변화시키는 명령어가 `>`밖에 없음을 생각하자. 이는 다시 말해 포인터의 값이 프로그램을 실행하면서 항상 단조증가한다는 것을 의미한다.

또한, 나머지 두 명령어는 포인터가 현재 가리키는 주소의 값을 변화시키므로, 프로그램이 실행된 후 만들어지는 수열 B는 다음과 같이 정의할 수 있다.

1. $i=1$, $n=1$로 둔다.
2. $i \in \mathbb{N}$ 에 대해, $B_i=0$이다.
3. $A_{L, R}$ 에서의 $n$번째 명령어 $A_{L+n-1}$ 에 따라, 다음을 실행한다.
    * $A_{L+n-1} =$ `+` 라면, $B_i$ 의 값에 1을 더한다.
    * $A_{L+n-1} =$ `-` 라면, $B_i$ 의 값에서 1을 뺀다.
    * $A_{L+n-1} =$ `>` 라면, $i$를 1 증가시킨다.

$$
    A_{L, R} = +++-->+--->>--+-+>
$$

<p align="center"> ↓ </p>

$$
    B = [1, -2, 0, -1, 0]
$$

다만, 2번 쿼리가 주어질 때마다 위의 정의를 반복해 적용하는 것은 $O(N)$ 의 시간 복잡도를 가지므로, 이를 효과적으로 해결하기 위해서는 $A_{L, R}$에서의 값을 효율적으로 관리해야 한다.

### Splay Tree
Splay Tree의 각 노드가 $i \in [1, N]$인 $A_i$에 따라 `+`, `-`, `>` 순서대로 1, -1, 0의 값을 갖는다고 하자.

여기서, 각각의 노드가 나타내는 구간은 두 자식 노드 중 왼쪽 자식의 구간, 자기 자신이 나타내는 구간, 오른쪽 자식이 나타내는 구간을 순서대로 연결한 구간으로 생각하자.

그렇다면 임의의 문자열 A는 Splay Tree를 전위 순회한 결과로 생각할 수 있고, 따라서 Splay Tree를 다음과 같이 구축할 수 있다.

$$
    >+>+-+++-->->>
$$

<p align="center"> ↓ </p>

<p align="center">
    <img src="./images/tree.png" width="40%" height="40%">
</p>

각 노드의 값이 두 자식 노드가 가진 값의 합이라고 정의하면, A에 `>`가 포함되지 않았을 때 2번 쿼리의 답이 되며, 각 노드의 값은 `+`를 1, `-`를 -1로 치환했을 때 자신이 나타내는 구간의 구간합이 된다.

`>`에 해당하는 노드의 경우 구간의 합이 해당 노드를 기준으로 둘로 나누어지므로, 각 노드에 2번 쿼리의 답을 저장하기 위해서는 다음과 같은 방법을 적용한다.

1. 각 노드에 자신이 나타내는 구간에 해당하는 문자열을 실행했을 때 생성되는 수열 B에 대한 다음 값을 저장한다.
    * B의 첫 번째 원소 → $B_{L}$
    * B의 마지막 원소 → $B_{R}$
    * $B_1$, $B_X$가 아닌 B의 원소 중 최댓값 → $B_{MIDMAX}$
    * 생성되는 수열 B의 길이 → $len$
2. Splay Tree를 초기화 및 업데이트할 때, 다음을 수행한다.
    1. 초기화 시, 노드가 나타내는 값은 다음과 같다.
        * $B_{L}$ = $B_{R}$ = (노드별로 할당된 $A_i$에 따른 값)
        * $B_{MIDMAX}$ = $-\infty$
    2. 업데이트 시 노드의 왼쪽 자식과 자신의 값을 합친다.
        * 자식 노드가 나타내는 문자열의 길이에 따라 케이스를 분리해 업데이트한다.
            * 자식 노드의 $len$이 1일 경우, 자신의 $B_{L}$에 자식 노드의 값을 더해준다.
                * 자신의 $len$도 1일 경우, 자신의 $B_{R}$에도 자식 노드의 값을 더해준다.
            * 자식 노드의 $len$이 1이 아닐 경우, 다음을 수행한다.
                * 자신의 $B_{L}$은 자식 노드의 $B_{L}$이 된다.
                * 자신의 $B_{MIDMAX}$은 $\textrm{max}$ (자식 노드의 $B_{MIDMAX}$, 자식 노드의 $B_{R}$, 자신의 $B_{L}$, 자신의 $B_{MIDMAX}$)
                * 만약 자신의 $len$이 1일 경우
                    * 자신의 $B_{R}$은 (자식 노드의 $B_{R}$ + 자신의 $B_{R}$)이 된다.
                    * 자신의 $B_{MIDMAX}$은 자식 노드의 $B_{MIDMAX}$이 된다.
            * 자신의 $len$은 (자식 노드의 $len$ + 자신의 $len$ - 1)이 된다.
    3. 업데이트 시 2.를 수행한 후 자신의 값과 오른쪽 자식의 값을 합친다.
        * 왼쪽 자식과 자신의 값을 합치는 과정과 같은 방법으로 수행한다.
        * 단, 위 과정에서의 왼쪽 자식이 자신이 되고, 위 과정에서의 자신이 오른쪽 자식이 된다.
    * 자식 노드가 없을 경우, 업데이트를 할 필요가 없다.

이렇게 Splay Tree를 구축해 두면, 2번 쿼리의 답을 계산하는 데 $\textrm{Amortized}\space O(\textrm{log}\space N)$의 시간 복잡도가 요구된다.